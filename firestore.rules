rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ========== HELPERS DE BASE ==========
    function isSignedIn() {
      return request.auth != null;
    }

    // ===== Custom claims (recommandé en prod) =====
    function roleClaim() {
      return isSignedIn() ? request.auth.token.role : null;
    }

    function groupIdClaim() {
      return isSignedIn() ? request.auth.token.groupId : null;
    }

    function hasUserDoc() {
      return isSignedIn() && exists(/databases/$(database)/documents/users/$(request.auth.uid));
    }

    function getUserData() {
      return hasUserDoc() 
        ? get(/databases/$(database)/documents/users/$(request.auth.uid)).data
        : null;
    }

    function roleDoc() {
      return hasUserDoc() ? getUserData().role : null;
    }

    function groupIdDoc() {
      return hasUserDoc() ? getUserData().groupId : null;
    }

    function userRole() {
      return roleClaim() != null ? roleClaim() : roleDoc();
    }

    function userGroupId() {
      // Compat app: si le userDoc n'a pas de groupId, l'app fallback sur 'default'.
      // Sans ça, les règles de publish MarketMap peuvent refuser (groupId null != 'default').
      return groupIdClaim() != null
        ? groupIdClaim()
        : (groupIdDoc() != null ? groupIdDoc() : 'default');
    }

    // ========== VÉRIFICATIONS DE RÔLES ==========
    // Rôles hiérarchiques:
    // - 'user' (utilisateur standard - priorité 10)
    // - 'tracker' (utilisateur traceur - priorité 20)
    // - 'group' / 'group-admin' (administrateur de groupe - priorité 50)
    // - 'admin' (administrateur master - priorité 90)
    // - 'superAdmin' / 'super-admin' (super administrateur - priorité 100)

    function isSuperAdmin() {
      return isSignedIn() && (
        userRole() == 'superAdmin'
        || userRole() == 'super-admin'
        || userRole() == 'superadmin'
      );
    }

    function isMasterAdmin() {
      return isSignedIn() && (
        (hasUserDoc() && getUserData().isAdmin == true)
        || userRole() == 'admin'
        || userRole() == 'admin_master'
        || userRole() == 'superAdmin'
        || userRole() == 'super-admin'
        || userRole() == 'superadmin'
      );
    }

    function isGroupAdmin(groupId) {
      return isSignedIn()
        && (
          userRole() == 'group'
          || userRole() == 'group-admin'
          || userRole() == 'admin_group'
          || userRole() == 'admin_groupe'
        )
        && userGroupId() == groupId;
    }

    // Alias explicites (compat avec la nomenclature demandée)
    function isAdminMaster() {
      return isSignedIn() && isMasterAdmin();
    }

    function isTracker() {
      return isSignedIn() && (userRole() == 'tracker_groupe' || userRole() == 'tracker');
    }

    // ========== VÉRIFICATIONS DE PERMISSIONS ==========
    function canManageUsers() {
      return isMasterAdmin();
    }

    function canManageContent() {
      return isMasterAdmin();
    }

    function canManageGroup(groupId) {
      return isMasterAdmin() || isGroupAdmin(groupId);
    }

    function canViewGroupData(groupId) {
      return isMasterAdmin() 
        || isGroupAdmin(groupId)
        || userGroupId() == groupId;
    }

    // Autorise l'écriture dans `marketMap` si et seulement si l'écriture est
    // rattachée à un projet `map_projects/{projectId}` du groupe de l'admin.
    // (Le chemin marketMap ne porte pas le groupId, on contrôle via sourceProjectId)
    function canWriteMarketMapFromProject() {
      // Par défaut: master admins uniquement.
      // En plus: doit référencer un projet existant (sourceProjectId) et appartenir au même groupe,
      // sauf superadmin (qui peut opérer cross-groupe).
      return isMasterAdmin()
        && (request.resource.data.sourceProjectId is string)
        && exists(/databases/$(database)/documents/map_projects/$(request.resource.data.sourceProjectId))
        && (
          isSuperAdmin()
          // Cas nominal: admin du même groupe.
          || projectGroupId(request.resource.data.sourceProjectId) == userGroupId()
          // Cas toléré: l'admin master publie SON projet (évite un blocage si son groupId n'est pas renseigné).
          || isProjectCreator(request.resource.data.sourceProjectId)
        );
    }

    // Delete n'a pas request.resource.data: on valide via resource.
    function canDeleteMarketMapFromProject() {
      return isMasterAdmin()
        && (resource.data.sourceProjectId is string)
        && exists(/databases/$(database)/documents/map_projects/$(resource.data.sourceProjectId))
        && (
          isSuperAdmin()
          // Cas nominal: admin du même groupe.
          || projectGroupId(resource.data.sourceProjectId) == userGroupId()
          // Cas toléré: l'admin master supprime SON circuit publié.
          || isProjectCreator(resource.data.sourceProjectId)
        );
    }

    // ========== COLLECTION: ROLES (Définitions des rôles) ==========
    match /roles/{roleId} {
      // Lecture: tous les utilisateurs authentifiés peuvent voir les définitions de rôles
      allow read: if isSignedIn();
      
      // Écriture: uniquement les super admins
      allow create, update, delete: if isSuperAdmin();
    }

    // ========== COLLECTION: USER CATEGORIES (Catégories d'utilisateurs) ==========
    match /userCategories/{categoryId} {
      // Lecture: tous les utilisateurs authentifiés peuvent voir les définitions de catégories
      allow read: if isSignedIn();
      
      // Écriture: uniquement les admins et super admins
      allow create, update, delete: if isMasterAdmin();
    }

    // ========== SOUS-COLLECTION: USER CATEGORY ASSIGNMENTS ==========
    match /users/{uid}/categories/{assignmentId} {
      // Lecture: utilisateur lui-même ou admins
      allow read: if isSignedIn() && (request.auth.uid == uid || isMasterAdmin());
      
      // Création: utilisateur pour les catégories auto-assignables, ou admins
      allow create: if isSignedIn() && (
        // L'utilisateur lui-même si la catégorie permet l'auto-assignation
        (request.auth.uid == uid && request.resource.data.requiresApproval == false)
        // Ou un admin
        || isMasterAdmin()
      );
      
      // Mise à jour/suppression: uniquement admins
      allow update, delete: if isMasterAdmin();
    }

    // ========== COLLECTION: USERS (Profils utilisateurs) ==========
    match /users/{uid} {
      // Lecture: utilisateur lui-même ou admins
      allow read: if isSignedIn() && (
        request.auth.uid == uid 
        || canManageUsers()
      );

      // Création: l'utilisateur crée son profil avec rôle 'user' par défaut,
      // ou admin peut créer pour d'autres
      allow create: if canManageUsers() || (
        isSignedIn()
        && request.auth.uid == uid
        && (request.resource.data.role == 'user' || !('role' in request.resource.data))
        && (!('isAdmin' in request.resource.data) || request.resource.data.isAdmin == false)
        && (!('groupId' in request.resource.data) || request.resource.data.groupId == null)
      );

      // Update: propriétaire peut modifier ses champs non privilégiés,
      // admin groupe peut modifier les membres de son groupe (sauf le rôle),
      // admin master peut tout modifier
      allow update: if canManageUsers() || (
        isSignedIn()
        && request.auth.uid == uid
        && request.resource.data.role == resource.data.role
        && request.resource.data.isAdmin == resource.data.isAdmin
        && request.resource.data.groupId == resource.data.groupId
        && request.resource.data.diff(resource.data).changedKeys().hasOnly([
          'email',
          'displayName',
          'photoUrl',
          'phone',
          'region',
          'fcmTokens',
          'updatedAt'
        ])
      ) || (
        // Admin groupe peut modifier les infos basiques des membres de son groupe
        isGroupAdmin(resource.data.groupId)
        && request.resource.data.role == resource.data.role
        && request.resource.data.isAdmin == resource.data.isAdmin
        && request.resource.data.groupId == resource.data.groupId
      );

      // Suppression: propriétaire ou admin master
      allow delete: if isSignedIn() && (
        request.auth.uid == uid 
        || canManageUsers()
      );

      // Sous-collections privées (cart, favorites, followingGroups, ...)
      match /{document=**} {
        allow read, write: if isSignedIn() && (
          request.auth.uid == uid 
          || canManageUsers()
        );
      }
    }

    // ========== COLLECTION: PLACES (Lieux) ==========
    match /places/{id} {
      // Lecture: publique
      allow read: if true;
      
      // Écriture: admins uniquement
      allow create, update, delete: if canManageContent();
    }

    // ========== COLLECTION: PRODUCT CATEGORIES ==========
    match /productCategories/{categoryId} {
      // Lecture: OK public (sert au filtrage UI). Ajuste à isSignedIn() si besoin.
      allow read: if true;
      // Écriture: admins master uniquement
      allow create, update, delete: if isMasterAdmin();
    }

    // Helpers produits (compat legacy/admin)
    function _productIsActive(data) {
      return (("isActive" in data) && data.isActive == true)
        || (("isAvailable" in data) && data.isAvailable == true);
    }

    function _productIsApproved(data) {
      return !("moderationStatus" in data) || data.moderationStatus == 'approved';
    }

    // Visibilité complémentaire pour le module commerce
    function _productIsVisibleFlag(data) {
      // Si le champ n'existe pas, on considère le produit visible (compat rétro)
      return !("isVisible" in data) || data.isVisible == true;
    }

    // Statut fonctionnel (draft/pending/approved/published/...)
    function _productStatusIsPublic(data) {
      // Si le champ n'existe pas, on ne filtre pas (compat rétro)
      return !("status" in data) || data.status in ['approved', 'published'];
    }

    function _productIsPublic(data) {
      return _productIsActive(data)
        && _productIsApproved(data)
        && _productIsVisibleFlag(data)
        && _productStatusIsPublic(data);
    }

    // Helpers média boutique (visibilité publique)
    function _mediaIsPublic(data) {
      // Si le champ n'existe pas, on considère le média visible (compat rétro)
      return !("isVisible" in data) || data.isVisible == true;
    }

    // ========== COLLECTION: PRODUCTS (Admin + compat) ==========
    match /products/{productId} {
      // Lecture: public uniquement si actif + approved (ou legacy sans moderationStatus)
      allow read: if _productIsPublic(resource.data) || isMasterAdmin();

      // CRUD: réservé aux admins master (dashboard Admin)
      allow create, update, delete: if isMasterAdmin();

      // Reviews (Storex)
      // Path: products/{productId}/reviews/{reviewId}
      match /reviews/{reviewId} {
        allow read: if true;

        allow create: if isSignedIn()
          && request.resource.data.uid == request.auth.uid
          && request.resource.data.rating is number
          && request.resource.data.rating >= 1
          && request.resource.data.rating <= 5
          && request.resource.data.comment is string
          && request.resource.data.comment.size() <= 2000
          && request.resource.data.authorName is string
          && request.resource.data.authorName.size() <= 80;

        // Optionnel: modification/suppression par l'auteur ou admin master
        allow update, delete: if isMasterAdmin()
          || (isSignedIn() && resource.data.uid == request.auth.uid);
      }
    }

    // ========== COLLECTION: SHOPS (boutique) ==========
    match /shops/{shopId} {
      // Lecture shop doc: publique (si tu stockes des infos de vitrine)
      allow read: if true;
      // Écriture shop doc: admins master uniquement
      allow create, update, delete: if isMasterAdmin();

      // Produits shop (utilisés via collectionGroup('products'))
      match /products/{productId} {
        allow read: if _productIsPublic(resource.data) || isMasterAdmin();
        allow create, update, delete: if isMasterAdmin();

        // Reviews (Storex) - alternative si produits uniquement sous shops
        match /reviews/{reviewId} {
          allow read: if true;

          allow create: if isSignedIn()
            && request.resource.data.uid == request.auth.uid
            && request.resource.data.rating is number
            && request.resource.data.rating >= 1
            && request.resource.data.rating <= 5
            && request.resource.data.comment is string
            && request.resource.data.comment.size() <= 2000
            && request.resource.data.authorName is string
            && request.resource.data.authorName.size() <= 80;

          allow update, delete: if isMasterAdmin()
            || (isSignedIn() && resource.data.uid == request.auth.uid);
        }
      }

      // Catégories shop
      match /categories/{categoryId} {
        allow read: if true;
        allow create, update, delete: if isMasterAdmin();
      }

      // Commandes shop (création authentifiée avec validation, lecture admin)
      match /orders/{orderId} {
        allow read: if isMasterAdmin();
        allow create: if isSignedIn()
          && request.resource.data.userId is string
          && request.resource.data.userId == request.auth.uid
          && request.resource.data.status is string
          && request.resource.data.totalPrice is number
          && request.resource.data.totalPrice > 0
          && request.resource.data.items is list
          && request.resource.data.items.size() > 0;
        allow update, delete: if isMasterAdmin();
      }
    }

    // ========== COLLECTION: BUSINESSES (Comptes professionnels) ==========
    match /businesses/{uid} {
      // Lecture: propriétaire ou admins master
      allow read: if isSignedIn() && (
        request.auth.uid == uid
        || isMasterAdmin()
      );

      // Création: uniquement le propriétaire, statut forcément 'pending'
      allow create: if isSignedIn()
        && request.auth.uid == uid
        && request.resource.data.ownerUid == uid
        && request.resource.data.status == 'pending'
        // Empêche la création directe d'un compte Stripe / d'un statut validé
        && !('stripe' in request.resource.data)
        && !('reviewedAt' in request.resource.data)
        && !('reviewedBy' in request.resource.data);

      // Update:
      // - Admins master: tout (gestion status, Stripe, etc.)
      // - Propriétaire: uniquement champs non privilégiés
      allow update: if isMasterAdmin() || (
        isSignedIn()
        && request.auth.uid == uid
        && (
          // Édition tant que pending
          (resource.data.status == 'pending' && request.resource.data.status == 'pending')
          // Re-soumission après rejet
          || (resource.data.status == 'rejected' && request.resource.data.status == 'pending')
        )
        && request.resource.data.ownerUid == resource.data.ownerUid
        // En pending, le propriétaire ne touche pas au motif
        && (resource.data.status != 'pending' || request.resource.data.rejectionReason == resource.data.rejectionReason)
        && request.resource.data.diff(resource.data).changedKeys().hasOnly([
          'email',
          'companyName',
          'siret',
          'legalForm',
          'activitySector',
          'numberOfEmployees',
          'tvaRegime',
          'address',
          'city',
          'postalCode',
          'region',
          'country',
          'phone',
          'firstName',
          'lastName',
          'status',
          'rejectionReason',
          'updatedAt'
        ])
      );

      // Suppression: admin master uniquement (évite la perte d'historique)
      allow delete: if isMasterAdmin();
    }

    // ========== COLLECTION: GROUPS (Groupes) ==========
    match /groups/{groupId} {
      // Lecture: publique
      allow read: if true;
      
      // Création: admin master uniquement
      allow create: if canManageContent();
      
      // Mise à jour: admin master ou admin du groupe spécifique
      allow update: if canManageGroup(groupId);
      
      // Suppression: admin master uniquement
      allow delete: if canManageContent();

      // Produits d’un groupe (shop)
      match /products/{productId} {
        // Lecture: public uniquement si validé (isActive=true), sinon réservé
        allow read: if resource.data.isActive == true || isMasterAdmin() || isGroupAdmin(groupId);

        // Création:
        // - master: libre
        // - admin groupe: UNIQUEMENT en attente (pending) et inactif
        allow create: if isMasterAdmin() || (
          isGroupAdmin(groupId)
          && request.resource.data.isActive == false
          && request.resource.data.moderationStatus == 'pending'
        );

        // Update:
        // - master: libre
        // - admin groupe: peut corriger tant que c'est pending/inactif
        //   et peut aussi resoumettre après refus (rejected -> pending)
        //   (interdit de passer actif/approved)
        allow update: if isMasterAdmin() || (
          isGroupAdmin(groupId)
          && resource.data.isActive == false
          && (resource.data.moderationStatus == 'pending' || resource.data.moderationStatus == 'rejected')
          && request.resource.data.isActive == false
          && request.resource.data.moderationStatus == 'pending'
        );

        allow delete: if isMasterAdmin() || isGroupAdmin(groupId);
      }

      // Historique points (écrit via Cloud Functions / Admin SDK)
      match /points/{pointId} {
        // Lecture: admin master ou admin groupe (sur SON groupe)
        allow read: if isMasterAdmin() || isGroupAdmin(groupId);
        allow create, update, delete: if false;
      }
    }

    // ========== COLLECTION: GROUP_LOCATIONS (Tracking en direct) ==========
    match /group_locations/{docId} {
      // Lecture: publique
      allow read: if true;
      
      // Écriture: via Cloud Functions uniquement
      allow create, update, delete: if false;
    }

    // ========== COLLECTION: POIs (Points d'intérêt) ==========
    match /pois/{id} {
      // Lecture: publique
      allow read: if true;
      
      // Écriture: admins uniquement
      allow create, update, delete: if canManageContent();
    }

    // ========== COLLECTION: CIRCUITS ==========
    match /circuits/{id} {
      // Lecture: publique
      allow read: if true;
      
      // Écriture: admins uniquement
      allow create, update, delete: if canManageContent();
    }

    // ========== COLLECTION: MARKETMAP (POIs / Circuits / Layers) ==========
    // Schéma:
    // marketMap/{countryId}/events/{eventId}/circuits/{circuitId}/layers/{layerId}
    // marketMap/{countryId}/events/{eventId}/circuits/{circuitId}/pois/{poiId}
    //
    // Lecture: publique (viewer web + mobile).
    // Écriture:
    // - Master admin: autorisé.
    // - Group-admin: non autorisé (édition/publish carte retirés).
    match /marketMap/{countryId} {
      allow read: if true;

      // Doc "pays" : essentiellement du metadata. Écriture réservée admin master.
      allow create, update: if isMasterAdmin();
      allow delete: if isMasterAdmin();

      match /events/{eventId} {
        allow read: if true;

        // Doc "event" : metadata. Écriture réservée admin master.
        allow create, update: if isMasterAdmin();
        allow delete: if isMasterAdmin();

        match /circuits/{circuitId} {
          allow read: if true;

          // Create: doit prouver l'appartenance via sourceProjectId.
          allow create: if canWriteMarketMapFromProject()
            && request.resource.data.countryId == countryId
            && request.resource.data.eventId == eventId;

          // Update: même contrainte (sur le circuit existant).
          allow update: if canWriteMarketMapFromProject()
            && request.resource.data.countryId == countryId
            && request.resource.data.eventId == eventId;

          // Delete: pas de request.resource.data, on valide via resource.
          allow delete: if canDeleteMarketMapFromProject()
            && resource.data.countryId == countryId
            && resource.data.eventId == eventId;

          match /layers/{layerId} {
            allow read: if true;
            allow create, update, delete: if isMasterAdmin();
          }

          match /pois/{poiId} {
            allow read: if true;
            allow create, update, delete: if isMasterAdmin();
          }
        }
      }
    }

    // ========== COLLECTION: CONFIG ==========
    match /config/{id} {
      // Lecture: publique
      allow read: if true;
      
      // Écriture: admins uniquement
      allow create, update, delete: if canManageContent();
    }

    // ========== COLLECTION: ORDERS (Commandes) ==========
    match /orders/{orderId} {
      // Lecture:
      // - Utilisateur: ses propres commandes
      // - Admin groupe: commandes de son groupe
      // - Admin master: toutes les commandes
      allow read: if isSignedIn() && (
        resource.data.userId == request.auth.uid
        || canManageContent()
        || canViewGroupData(resource.data.groupId)
        || (('sellerIds' in resource.data)
            && (resource.data.sellerIds is list)
            && resource.data.sellerIds.hasAny([request.auth.uid]))
      );
      
      // Création: utilisateur authentifié avec son propre userId
      allow create: if isSignedIn()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.keys().hasAll(['userId', 'groupId', 'items', 'totalPrice']);
      
      // Mise à jour/Suppression: admin master
      // + vendeur: peut uniquement valider/rejeter (champs limités)
      allow update: if canManageContent() || (
        isSignedIn()
        && (('sellerIds' in resource.data)
            && (resource.data.sellerIds is list)
            && resource.data.sellerIds.hasAny([request.auth.uid]))
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.groupId == resource.data.groupId
        && request.resource.data.diff(resource.data).changedKeys().hasOnly([
          'status',
          'updatedAt',
          'validatedAt',
          'rejectedAt'
        ])
        && (request.resource.data.status in ['validated', 'rejected'])
      );

      allow delete: if canManageContent();
    }

    // ========== COLLECTION: COMMERCE SUBMISSIONS (Soumissions commerce) ==========
    match /commerce_submissions/{submissionId} {
      // Helper: vérifier si l'utilisateur peut soumettre du commerce
      function canSubmitCommerce() {
        return hasUserDoc() && (
          isMasterAdmin()
          || userRole() == 'admin_groupe'
          || (getUserData().accountType == 'pro' && getUserData().keys().hasAny(['activities']))
          || userRole() == 'superadmin'
        );
      }

      // Helper: vérifier si l'utilisateur peut modérer
      function canModerate() {
        return isMasterAdmin()
          || (userRole() == 'admin_groupe' 
              && resource.data.scopeType == 'group' 
              && getUserData().keys().hasAny(['managedScopeIds']) 
              && getUserData().managedScopeIds.hasAny([resource.data.scopeId]));
      }

      // Lecture:
      // - Propriétaire peut lire ses propres soumissions
      // - Modérateurs peuvent lire les soumissions pending
      // - Admins peuvent tout lire
      allow read: if isSignedIn() && (
        resource.data.ownerUid == request.auth.uid
        || canModerate()
        || isMasterAdmin()
      );

      // Création:
      // - Utilisateur autorisé avec un rôle valide
      // - Doit définir ownerUid = request.auth.uid
      // - Statut initial = 'draft' ou 'pending'
      allow create: if isSignedIn() 
        && canSubmitCommerce()
        && request.resource.data.ownerUid == request.auth.uid
        && request.resource.data.status in ['draft', 'pending']
        && !request.resource.data.keys().hasAny(['moderatedBy', 'moderatedAt', 'publishedRef']);

      // Mise à jour:
      // - Propriétaire peut modifier ses soumissions draft ou rejected
      //   MAIS ne peut pas toucher aux champs de modération ni passer en 'approved'
      // - Modérateurs peuvent modifier status, moderatedBy, moderatedAt, moderationNote, publishedRef
      allow update: if isSignedIn() && (
        // Propriétaire peut modifier draft/rejected
        (resource.data.ownerUid == request.auth.uid
         && resource.data.status in ['draft', 'rejected']
         && !request.resource.data.diff(resource.data).affectedKeys().hasAny(['moderatedBy', 'moderatedAt', 'publishedRef'])
         && request.resource.data.status != 'approved')
        ||
        // Modérateurs peuvent approuver/refuser
        (canModerate() || isMasterAdmin())
      );

      // Suppression:
      // - Propriétaire peut supprimer draft ou rejected
      // - Admins peuvent tout supprimer
      allow delete: if isSignedIn() && (
        (resource.data.ownerUid == request.auth.uid && resource.data.status in ['draft', 'rejected'])
        || isMasterAdmin()
      );
    }

    // ========== COLLECTIONS: SHOPS (Boutiques publiques) ==========
    // /shops/{scopeId}/products et /shops/{scopeId}/media
    // Lecture publique (uniquement éléments marqués visibles/publics),
    // écriture uniquement par service ou superadmin
    match /shops/{scopeId}/products/{productId} {
      // Lecture publique des produits "publics" (actifs + approuvés + visibles)
      allow read: if _productIsPublic(resource.data) || isMasterAdmin();

      // Écriture: uniquement superadmin (ou service account via Cloud Functions)
      allow create, update, delete: if isSuperAdmin();
    }

    match /shops/{scopeId}/media/{mediaId} {
      // Lecture publique des médias marqués visibles
      allow read: if _mediaIsPublic(resource.data) || isMasterAdmin();

      // Écriture: uniquement superadmin (ou service account via Cloud Functions)
      allow create, update, delete: if isSuperAdmin();
    }

    // ========== MODULE: GROUP ADMIN / TRACKER (tracking + boutique groupe) ==========
    function isGroupAdminByAdminGroupId(adminGroupId) {
      return adminGroupId != null
        && isSignedIn()
        && exists(/databases/$(database)/documents/group_admins/$(request.auth.uid))
        && get(/databases/$(database)/documents/group_admins/$(request.auth.uid)).data.adminGroupId == adminGroupId;
    }

    function isTrackerByAdminGroupId(adminGroupId) {
      return adminGroupId != null
        && isSignedIn()
        && exists(/databases/$(database)/documents/group_trackers/$(request.auth.uid))
        && get(/databases/$(database)/documents/group_trackers/$(request.auth.uid)).data.adminGroupId == adminGroupId;
    }

    function isGroupMemberByAdminGroupId(adminGroupId) {
      return isGroupAdminByAdminGroupId(adminGroupId) || isTrackerByAdminGroupId(adminGroupId);
    }

    // Profils admins de groupe
    match /group_admins/{adminUid} {
      allow read: if isSignedIn() && (
        request.auth.uid == adminUid
        || isMasterAdmin()
        || isTrackerByAdminGroupId(resource.data.adminGroupId)
      );

      allow create: if isSignedIn()
        && request.auth.uid == adminUid
        && (request.resource.data.adminGroupId is string)
        && request.resource.data.adminGroupId.matches('^\\d{6}$');

      allow update: if isSignedIn() && (
        request.auth.uid == adminUid
        || isMasterAdmin()
      );

      allow delete: if isMasterAdmin();
    }

    // Répertoire des codes admin (lookup)
    match /group_admin_codes/{code} {
      allow read: if isSignedIn();

      allow create: if isSignedIn()
        && (code is string)
        && code.matches('^\\d{6}$')
        && request.resource.data.adminUid == request.auth.uid
        && (request.resource.data.isActive == true);

      allow update: if isSignedIn() && (
        isMasterAdmin()
        || (resource.data.adminUid == request.auth.uid
            && request.resource.data.adminUid == resource.data.adminUid)
      );

      allow delete: if isMasterAdmin();
    }

    // Profils trackers
    match /group_trackers/{trackerUid} {
      allow read: if isSignedIn() && (
        request.auth.uid == trackerUid
        || isMasterAdmin()
        || isGroupAdminByAdminGroupId(resource.data.adminGroupId)
      );

      allow create, update: if isSignedIn() && request.auth.uid == trackerUid;
      allow delete: if isMasterAdmin();
    }

    // Positions live par membre (source d'agrégation CF)
    match /group_positions/{adminGroupId} {
      allow read: if isSignedIn() && (isGroupMemberByAdminGroupId(adminGroupId) || isMasterAdmin());
      allow write: if false;

      match /members/{uid} {
        allow read: if isSignedIn() && (isGroupMemberByAdminGroupId(adminGroupId) || isMasterAdmin());
        allow create, update: if isSignedIn()
          && request.auth.uid == uid
          && isGroupMemberByAdminGroupId(adminGroupId);
        allow delete: if isMasterAdmin();
      }
    }

    // Historique des sessions + points
    match /group_tracks/{adminGroupId} {
      allow read: if false;
      allow write: if false;

      match /sessions/{sessionId} {
        allow read: if isSignedIn() && (
          isMasterAdmin()
          || isGroupAdminByAdminGroupId(adminGroupId)
          || resource.data.uid == request.auth.uid
        );

        allow create: if isSignedIn()
          && isGroupMemberByAdminGroupId(adminGroupId)
          && request.resource.data.uid == request.auth.uid
          && request.resource.data.adminGroupId == adminGroupId
          && request.resource.data.role in ['admin', 'tracker'];

        allow update: if isSignedIn() && (
          isMasterAdmin()
          || (resource.data.uid == request.auth.uid
              && request.resource.data.uid == resource.data.uid
              && request.resource.data.adminGroupId == resource.data.adminGroupId)
        );

        allow delete: if isMasterAdmin();

        match /points/{pointId} {
          function _sessionDoc() {
            return get(/databases/$(database)/documents/group_tracks/$(adminGroupId)/sessions/$(sessionId)).data;
          }

          allow read: if isSignedIn() && (
            isMasterAdmin()
            || isGroupAdminByAdminGroupId(adminGroupId)
            || _sessionDoc().uid == request.auth.uid
          );

          allow create: if isSignedIn()
            && isGroupMemberByAdminGroupId(adminGroupId)
            && _sessionDoc().uid == request.auth.uid;

          allow update, delete: if false;
        }
      }
    }

    // Boutique groupe (produits + médias)
    match /group_shops/{adminGroupId} {
      allow read: if isSignedIn() && (isGroupMemberByAdminGroupId(adminGroupId) || isMasterAdmin());
      allow write: if false;

      match /products/{productId} {
        allow read: if isSignedIn() && (isGroupMemberByAdminGroupId(adminGroupId) || isMasterAdmin());
        allow create, update, delete: if isSignedIn() && (
          isMasterAdmin() || isGroupAdminByAdminGroupId(adminGroupId)
        );
      }

      match /media/{mediaId} {
        allow read: if isSignedIn() && (isGroupMemberByAdminGroupId(adminGroupId) || isMasterAdmin());
        allow create, update, delete: if isSignedIn() && (
          isMasterAdmin() || isGroupAdminByAdminGroupId(adminGroupId)
        );
      }
    }

    // Articles Superadmin (casquette, tshirt, porteclé, bandana)
    match /superadmin_articles/{articleId} {
      // Tous les utilisateurs peuvent lire les articles actifs
      allow read: if isSignedIn() && resource.data.isActive == true;
      
      // Seul le superadmin peut créer, modifier, supprimer
      allow create, update, delete: if isSuperAdmin();
    }

    // ========== COLLECTION: MAP_PROJECTS (Circuit Wizard Pro SaaS Pro 2026) ==========
    function mapProjectDoc(projectId) {
      return get(/databases/$(database)/documents/map_projects/$(projectId)).data;
    }

    function isProjectCreator(projectId) {
      return isSignedIn()
        && (
          mapProjectDoc(projectId).createdBy == request.auth.uid
          || mapProjectDoc(projectId).uid == request.auth.uid
        );
    }

    function projectGroupId(projectId) {
      return mapProjectDoc(projectId).groupId;
    }

    function canReadProject(projectId) {
      return exists(/databases/$(database)/documents/map_projects/$(projectId))
        && (
          // Wizard = admin-only (ou créateur). Les projets publiés sont consommés via marketMap.
          isMasterAdmin()
          || isProjectCreator(projectId)
        );
    }

    function canPublishProject() {
      return isMasterAdmin();
    }

    function isAllowedStatus(status) {
      return status in ['draft', 'published'];
    }

    function validPointListShape(points, maxSize) {
      return points is list
        && points.size() <= maxSize
        && (
          points.size() == 0
          || (
            points[0] is map
            && points[0].lat is number
            && points[0].lng is number
          )
        );
    }

    function validCurrentShape(current) {
      return current is map
        && current.name is string
        && current.countryId is string
        && current.eventId is string
        && current.routeStyle is map
        && validPointListShape(current.route, 5000)
        && validPointListShape(current.perimeter, 1000);
    }

    function validProjectPayloadCreate() {
      return request.resource.data.uid == request.auth.uid
        && request.resource.data.createdBy == request.auth.uid
        && request.resource.data.groupId is string
        && (isMasterAdmin() || request.resource.data.groupId == userGroupId())
        && request.resource.data.sourceOfTruth == 'map_projects'
        && request.resource.data.current is map
        && validCurrentShape(request.resource.data.current)
        && isAllowedStatus(request.resource.data.status)
        // Canon: current.route/current.perimeter.
        // Top-level route/perimeter tolérés (compat rétro) mais optionnels.
        && (!('route' in request.resource.data) || validPointListShape(request.resource.data.route, 5000))
        && (!('perimeter' in request.resource.data) || validPointListShape(request.resource.data.perimeter, 1000));
    }

    function validProjectPayloadUpdate() {
      return request.resource.data.sourceOfTruth == 'map_projects'
        && request.resource.data.uid == resource.data.uid
        && request.resource.data.createdBy == resource.data.createdBy
        && request.resource.data.groupId == resource.data.groupId
        && request.resource.data.current is map
        && validCurrentShape(request.resource.data.current)
        && isAllowedStatus(request.resource.data.status)
        && (!('route' in request.resource.data) || validPointListShape(request.resource.data.route, 5000))
        && (!('perimeter' in request.resource.data) || validPointListShape(request.resource.data.perimeter, 1000))
        && (
          resource.data.status != 'draft'
          || request.resource.data.status != 'published'
          || canPublishProject()
        );
    }

    function isAllowedAuditAction(action) {
      return action in [
        'create_project',
        'save_draft',
        'restore_draft',
        'publish',
        'update_style',
        'update_route',
        'update_pois'
      ];
    }

    match /map_projects/{projectId} {
      allow create: if isSignedIn()
        && isMasterAdmin()
        && validProjectPayloadCreate();

      // Lecture publique UNIQUEMENT si published (sinon: admins/créateur)
      // IMPORTANT: pour les requêtes (liste), Firestore exige que TOUS les documents potentiellement
      // retournés soient autorisés. On évite ici les dépendances `get()` sur le même document
      // (source fréquente de "permission-denied" en liste) et on s'appuie sur `resource.data`.
      allow read: if isSignedIn() && (
        isMasterAdmin()
        || resource.data.createdBy == request.auth.uid
        || resource.data.uid == request.auth.uid
      );

      allow update: if isSignedIn()
        && isMasterAdmin()
        && validProjectPayloadUpdate();

      allow delete: if isSignedIn() && isMasterAdmin();

      match /layers/{layerId} {
        allow read: if canReadProject(projectId);
        allow create, update, delete: if isSignedIn() && (
          isMasterAdmin()
        );
      }

      match /pois/{poiId} {
        allow read: if canReadProject(projectId);
        allow create, update, delete: if isSignedIn() && (
          isMasterAdmin()
        );
      }

      match /drafts/{draftId} {
        // Historique interne: jamais public
        allow read: if isSignedIn() && (
          isMasterAdmin() || isProjectCreator(projectId)
        );
        allow create, update, delete: if isSignedIn() && (
          isMasterAdmin()
        );
      }

      // ===== Live locations (écriture uniquement par soi-même, lecture restreinte) =====
      match /live_locations/{uid} {
        // Interdit au public: positions individuelles
        allow read: if isAdminMaster();

        allow create, update: if isSignedIn()
          && request.auth.uid == uid
          && isTracker()
          && request.resource.data.keys().hasAll([
              'groupId', 'roleInGroup', 'pos', 'updatedAt', 'expiresAt'
          ])
          && request.resource.data.keys().hasOnly([
              'groupId', 'roleInGroup', 'pos', 'heading', 'speed', 'accuracy', 'updatedAt', 'expiresAt'
          ])
          && request.resource.data.groupId is string
          && request.resource.data.groupId == projectGroupId(projectId)
          && request.resource.data.roleInGroup == 'tracker'
            && request.resource.data.pos is latlng
          && (!('heading' in request.resource.data) || request.resource.data.heading is number)
          && (!('speed' in request.resource.data) || request.resource.data.speed is number)
          && (!('accuracy' in request.resource.data) || request.resource.data.accuracy is number)
          && request.resource.data.updatedAt is timestamp
          && request.resource.data.expiresAt is timestamp;

        allow delete: if isSignedIn() && request.auth.uid == uid;
      }

      // ===== Group presence (lecture publique si published) =====
      match /group_presence/{groupId} {
        allow read: if canReadProject(projectId);
        // Écriture réservée au serveur (Admin SDK) OU admin master
        allow create, update, delete: if isAdminMaster();
      }
    }

    // ========== COLLECTION: AUDIT EVENTS ==========
    match /audit_events/{eventId} {
      allow read: if isSignedIn() && isMasterAdmin();
      allow create: if isSignedIn()
        && request.resource.data.actorUid == request.auth.uid
        && request.resource.data.actorRole is string
        && isAllowedAuditAction(request.resource.data.action)
        && request.resource.data.target is map
        && request.resource.data.target.projectId is string
        && request.resource.data.target.groupId is string;
      allow update, delete: if false;
    }

    // ========== COLLECTION: CIRCUIT TEMPLATES ==========
    match /circuit_templates/{templateId} {
      allow read: if isSignedIn();
      allow create, update, delete: if isSignedIn() && isMasterAdmin();
    }

    // ========== COLLECTION: IMAGE ASSETS (métadonnées upload images) ==========
    // Écrit par ImageManagementService lors d'un upload (variants + metadata).
    match /image_assets/{imageId} {
      allow read: if isSignedIn();
      allow create, update, delete: if isSignedIn() && isMasterAdmin();
    }

    // ========== REFUS PAR DÉFAUT ==========
    match /{document=**} {
      allow read, write: if false;
    }

  }
}

